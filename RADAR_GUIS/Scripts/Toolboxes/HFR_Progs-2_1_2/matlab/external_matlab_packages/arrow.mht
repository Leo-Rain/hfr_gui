From: <Saved by Microsoft Internet Explorer 5>
Subject: 
Date: Thu, 5 Apr 2007 16:24:38 -0400
MIME-Version: 1.0
Content-Type: text/html;
	charset="Windows-1252"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.mathworks.com/matlabcentral/files/278/arrow.m
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.2180

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Dwindows-1252">
<META content=3D"MSHTML 6.00.2900.2627" name=3DGENERATOR></HEAD>
<BODY><PRE>function [h,yy,zz] =3D arrow(varargin)
% ARROW  Draw a line with an arrowhead.
%
%  ARROW(Start,Stop) draws a line with an arrow from Start to Stop =
(points
%        should be vectors of length 2 or 3, or matrices with 2 or 3
%        columns), and returns the graphics handle of the arrow(s).
%
%  ARROW uses the mouse (click-drag) to create an arrow.
%
%  ARROW DEMO &amp; ARROW DEMO2 show 3-D &amp; 2-D demos of the =
capabilities of ARROW.
%
%  ARROW may be called with a normal argument list or a property-based =
list.
%        ARROW(Start,Stop,Length,BaseAngle,TipAngle,Width,Page,CrossDir) =
is
%        the full normal argument list, where all but the Start and Stop
%        points are optional.  If you need to specify a later argument =
(e.g.,
%        Page) but want default values of earlier ones (e.g., TipAngle),
%        pass an empty matrix for the earlier ones (e.g., =
TipAngle=3D[]).
%
%  ARROW('Property1',PropVal1,'Property2',PropVal2,...) creates arrows =
with the
%        given properties, using default values for any unspecified or =
given as
%        'default' or NaN.  Some properties used for line and patch =
objects are
%        used in a modified fashion, others are passed directly to LINE, =
PATCH,
%        or SET.  For a detailed properties explanation, call ARROW =
PROPERTIES.
%
%        Start         The starting points.                     B
%        Stop          The end points.                         /|\       =
    ^
%        Length        Length of the arrowhead in pixels.     /|||\      =
    |
%        BaseAngle     Base angle in degrees (ADE).          //|||\\     =
   L|
%        TipAngle      Tip angle in degrees (ABC).          ///|||\\\    =
   e|
%        Width         Width of the base in pixels.        ////|||\\\\   =
   n|
%        Page          Use hardcopy proportions.          /////|D|\\\\\  =
   g|
%        CrossDir      Vector || to arrowhead plane.     ////  |||  \\\\ =
   t|
%        NormalDir     Vector out of arrowhead plane.   ///    |||    =
\\\   h|
%        Ends          Which end has an arrowhead.     //&lt;-----&gt;|| =
     \\   |
%        ObjectHandles Vector of handles to update.   /   base |||       =
 \  V
%                                                    E    =
angle||&lt;--------&gt;C
%  ARROW(H,'Prop1',PropVal1,...), where H is a                 =
|||tipangle
%        vector of handles to previously-created arrows        |||
%        and/or line objects, will update the previously-      |||
%        created arrows according to the current view       =
--&gt;|A|&lt;-- width
%        and any specified properties, and will convert
%        two-point line objects to corresponding arrows.  ARROW(H) will =
update
%        the arrows if the current view has changed.  Root, figure, or =
axes
%        handles included in H are replaced by all descendant Arrow =
objects.
%
%  A property list can follow any specified normal argument list, e.g.,
%  ARROW([1 2 3],[0 0 0],36,'BaseAngle',60) creates an arrow from =
(1,2,3) to
%  the origin, with an arrowhead of length 36 pixels and 60-degree base =
angle.
%
%  The basic arguments or properties can generally be vectorized to =
create
%  multiple arrows with the same call.  This is done by passing a =
property
%  with one row per arrow, or, if all arrows are to have the same =
property
%  value, just one row may be specified.
%
%  You may want to execute AXIS(AXIS) before calling ARROW so it doesn't =
change
%  the axes on you; ARROW determines the sizes of arrow components =
BEFORE the
%  arrow is plotted, so if ARROW changes axis limits, arrows may be =
malformed.
%
%  This version of ARROW uses features of MATLAB 5 and is incompatible =
with
%  earlier MATLAB versions (ARROW for MATLAB 4.2c is available =
separately);
%  some problems with perspective plots still exist.

% Copyright (c)1995-2002, Dr. Erik A. Johnson &lt;JohnsonE@usc.edu&gt;, =
11/15/02

% Revision history:
%   11/15/02  EAJ  Accomodate how MATLAB 6.5 handles NaN and logicals
%    7/28/02  EAJ  Tried (but failed) work-around for MATLAB 6.x / =
OpenGL bug
%                    if zero 'Width' or not double-ended
%   11/10/99  EAJ  Add logical() to eliminate zero index problem in =
MATLAB 5.3.
%   11/10/99  EAJ  Corrected warning if axis limits changed on multiple =
axes.
%   11/10/99  EAJ  Update e-mail address.
%    2/10/99  EAJ  Some documentation updating.
%    2/24/98  EAJ  Fixed bug if Start~=3DStop but both colinear with =
viewpoint.
%    8/14/97  EAJ  Added workaround for MATLAB 5.1 scalar logical =
transpose bug.
%    7/21/97  EAJ  Fixed a few misc bugs.
%    7/14/97  EAJ  Make arrow([],'Prop',...) do nothing (no old handles)
%    6/23/97  EAJ  MATLAB 5 compatible version, release.
%    5/27/97  EAJ  Added Line Arrows back in.  Corrected a few bugs.
%    5/26/97  EAJ  Changed missing Start/Stop to mouse-selected arrows.
%    5/19/97  EAJ  MATLAB 5 compatible version, beta.
%    4/13/97  EAJ  MATLAB 5 compatible version, alpha.
%    1/31/97  EAJ  Fixed bug with multiple arrows and unspecified Z =
coords.
%   12/05/96  EAJ  Fixed one more bug with log plots and NormalDir =
specified
%   10/24/96  EAJ  Fixed bug with log plots and NormalDir specified
%   11/13/95  EAJ  Corrected handling for 'reverse' axis directions
%   10/06/95  EAJ  Corrected occasional conflict with SUBPLOT
%    4/24/95  EAJ  A major rewrite.
%    Fall 94  EAJ  Original code.

% Things to be done:
%  - segment parsing, computing, and plotting into separate subfunctions
%  - change computing from Xform to Camera paradigms
%     + this will help especially with 3-D perspective plots
%     + if the WarpToFill section works right, remove warning code
%     + when perpsective works properly, remove perspective warning code
%  - add cell property values and struct property name/values (like =
get/set)
%  - get rid of NaN as the "default" data label
%     + perhaps change userdata to a struct and don't include (or leave
%       empty) the values specified as default; or use a cell containing
%       an empty matrix for a default value
%  - add functionality of GET to retrieve current values of ARROW =
properties

% Many thanks to Keith Rogers &lt;kerog@ai.mit.com&gt; for his many =
excellent
% suggestions and beta testing.  Check out his shareware package MATDRAW
% (at ftp://ftp.mathworks.com/pub/contrib/v5/graphics/matdraw/) -- he =
has
% permission to distribute ARROW with MATDRAW.

% Permission is granted to distribute ARROW with the toolboxes for the =
book
% "Solving Solid Mechanics Problems with MATLAB 5", by F. Golnaraghi et =
al.
% (Prentice Hall, 1999).

% global variable initialization
global ARROW_PERSP_WARN ARROW_STRETCH_WARN ARROW_AXLIMITS
if isempty(ARROW_PERSP_WARN  ), ARROW_PERSP_WARN  =3D1; end;
if isempty(ARROW_STRETCH_WARN), ARROW_STRETCH_WARN=3D1; end;

% Handle callbacks
if (nargin&gt;0 &amp; isstr(varargin{1}) &amp; =
strcmp(lower(varargin{1}),'callback')),
	arrow_callback(varargin{2:end}); return;
end;

% Are we doing the demo?
c =3D sprintf('\n');
if (nargin=3D=3D1 &amp; isstr(varargin{1})),
	arg1 =3D lower(varargin{1});
	if strncmp(arg1,'prop',4), arrow_props;
	elseif strncmp(arg1,'demo',4)
		clf reset
		demo_info =3D arrow_demo;
		if ~strncmp(arg1,'demo2',5),
			hh=3Darrow_demo3(demo_info);
		else,
			hh=3Darrow_demo2(demo_info);
		end;
		if (nargout&gt;=3D1), h=3Dhh; end;
	elseif strncmp(arg1,'fixlimits',3),
		arrow_fixlimits(ARROW_AXLIMITS);
		ARROW_AXLIMITS=3D[];
	elseif strncmp(arg1,'help',4),
		disp(help(mfilename));
	else,
		error([upper(mfilename) ' got an unknown single-argument string ''' =
deblank(arg1) '''.']);
	end;
	return;
end;

% Check # of arguments
if (nargout&gt;3), error([upper(mfilename) ' produces at most 3 output =
arguments.']); end;

% find first property number
firstprop =3D nargin+1;
for k=3D1:length(varargin), if ~isnumeric(varargin{k}), firstprop=3Dk; =
break; end; end;
lastnumeric =3D firstprop-1;

% check property list
if (firstprop&lt;=3Dnargin),
	for k=3Dfirstprop:2:nargin,
		curarg =3D varargin{k};
		if ~isstr(curarg) | sum(size(curarg)&gt;1)&gt;1,
			error([upper(mfilename) ' requires that a property name be a single =
string.']);
		end;
	end;
	if (rem(nargin-firstprop,2)~=3D1),
		error([upper(mfilename) ' requires that the property ''' ...
		       varargin{nargin} ''' be paired with a property value.']);
	end;
end;

% default output
if (nargout&gt;0), h=3D[]; end;
if (nargout&gt;1), yy=3D[]; end;
if (nargout&gt;2), zz=3D[]; end;

% set values to empty matrices
start      =3D [];
stop       =3D [];
len        =3D [];
baseangle  =3D [];
tipangle   =3D [];
wid        =3D [];
page       =3D [];
crossdir   =3D [];
ends       =3D [];
ax         =3D [];
oldh       =3D [];
ispatch    =3D [];
defstart      =3D [NaN NaN NaN];
defstop       =3D [NaN NaN NaN];
deflen        =3D 16;
defbaseangle  =3D 90;
deftipangle   =3D 16;
defwid        =3D 0;
defpage       =3D 0;
defcrossdir   =3D [NaN NaN NaN];
defends       =3D 1;
defoldh       =3D [];
defispatch    =3D 1;

% The 'Tag' we'll put on our arrows
ArrowTag =3D 'Arrow';

% check for oldstyle arguments
if (firstprop=3D=3D2),
	% assume arg1 is a set of handles
	oldh =3D varargin{1}(:);
	if isempty(oldh), return; end;
elseif (firstprop&gt;9),
	error([upper(mfilename) ' takes at most 8 non-property arguments.']);
elseif (firstprop&gt;2),
	s =3D =
str2mat('start','stop','len','baseangle','tipangle','wid','page','crossdi=
r');
	for k=3D1:firstprop-1, eval([deblank(s(k,:)) '=3Dvarargin{k};']); end;
end;

% parse property pairs
extraprops=3D{};
for k=3Dfirstprop:2:nargin,
	prop =3D varargin{k};
	val  =3D varargin{k+1};
	prop =3D [lower(prop(:)') '      '];
	if     strncmp(prop,'start' ,5),   start      =3D val;
	elseif strncmp(prop,'stop'  ,4),   stop       =3D val;
	elseif strncmp(prop,'len'   ,3),   len        =3D val(:);
	elseif strncmp(prop,'base'  ,4),   baseangle  =3D val(:);
	elseif strncmp(prop,'tip'   ,3),   tipangle   =3D val(:);
	elseif strncmp(prop,'wid'   ,3),   wid        =3D val(:);
	elseif strncmp(prop,'page'  ,4),   page       =3D val;
	elseif strncmp(prop,'cross' ,5),   crossdir   =3D val;
	elseif strncmp(prop,'norm'  ,4),   if (isstr(val)), crossdir=3Dval; =
else, crossdir=3Dval*sqrt(-1); end;
	elseif strncmp(prop,'end'   ,3),   ends       =3D val;
	elseif strncmp(prop,'object',6),   oldh       =3D val(:);
	elseif strncmp(prop,'handle',6),   oldh       =3D val(:);
	elseif strncmp(prop,'type'  ,4),   ispatch    =3D val;
	elseif strncmp(prop,'userd' ,5),   %ignore it
	else,
		% make sure it is a valid patch or line property
		eval('get(0,[''DefaultPatch'' varargin{k}]);err=3D0;','err=3D1;'); =
errstr=3Dlasterr;
		if (err), eval('get(0,[''DefaultLine'' =
varargin{k}]);err=3D0;','err=3D1;'); end;
		if (err),
			errstr(1:max(find(errstr=3D=3Dsetstr(13)|errstr=3D=3Dsetstr(10)))) =
=3D '';
			error([upper(mfilename) ' got ' errstr]);
		end;
		extraprops=3D{extraprops{:},varargin{k},val};
	end;
end;

% Check if we got 'default' values
start     =3D arrow_defcheck(start    ,defstart    ,'Start'        );
stop      =3D arrow_defcheck(stop     ,defstop     ,'Stop'         );
len       =3D arrow_defcheck(len      ,deflen      ,'Length'       );
baseangle =3D arrow_defcheck(baseangle,defbaseangle,'BaseAngle'    );
tipangle  =3D arrow_defcheck(tipangle ,deftipangle ,'TipAngle'     );
wid       =3D arrow_defcheck(wid      ,defwid      ,'Width'        );
crossdir  =3D arrow_defcheck(crossdir ,defcrossdir ,'CrossDir'     );
page      =3D arrow_defcheck(page     ,defpage     ,'Page'         );
ends      =3D arrow_defcheck(ends     ,defends     ,''             );
oldh      =3D arrow_defcheck(oldh     ,[]          ,'ObjectHandles');
ispatch   =3D arrow_defcheck(ispatch  ,defispatch  ,''             );

% check transpose on arguments
[m,n]=3Dsize(start   );   if any(m=3D=3D[2 3])&amp;(n=3D=3D1|n&gt;3),   =
start    =3D start';      end;
[m,n]=3Dsize(stop    );   if any(m=3D=3D[2 3])&amp;(n=3D=3D1|n&gt;3),   =
stop     =3D stop';       end;
[m,n]=3Dsize(crossdir);   if any(m=3D=3D[2 3])&amp;(n=3D=3D1|n&gt;3),   =
crossdir =3D crossdir';   end;

% convert strings to numbers
if ~isempty(ends) &amp; isstr(ends),
	endsorig =3D ends;
	[m,n] =3D size(ends);
	col =3D lower([ends(:,1:min(3,n)) ones(m,max(0,3-n))*' ']);
	ends =3D NaN*ones(m,1);
	oo =3D ones(1,m);
	ii=3Dfind(all(col'=3D=3D['non']'*oo)'); if ~isempty(ii), =
ends(ii)=3Dones(length(ii),1)*0; end;
	ii=3Dfind(all(col'=3D=3D['sto']'*oo)'); if ~isempty(ii), =
ends(ii)=3Dones(length(ii),1)*1; end;
	ii=3Dfind(all(col'=3D=3D['sta']'*oo)'); if ~isempty(ii), =
ends(ii)=3Dones(length(ii),1)*2; end;
	ii=3Dfind(all(col'=3D=3D['bot']'*oo)'); if ~isempty(ii), =
ends(ii)=3Dones(length(ii),1)*3; end;
	if any(isnan(ends)),
		ii =3D min(find(isnan(ends)));
		error([upper(mfilename) ' does not recognize ''' =
deblank(endsorig(ii,:)) ''' as a valid ''Ends'' value.']);
	end;
else,
	ends =3D ends(:);
end;
if ~isempty(ispatch) &amp; isstr(ispatch),
	col =3D lower(ispatch(:,1));
	patchchar=3D'p'; linechar=3D'l'; defchar=3D' ';
	mask =3D col~=3Dpatchchar &amp; col~=3Dlinechar &amp; col~=3Ddefchar;
	if any(mask),
		error([upper(mfilename) ' does not recognize ''' =
deblank(ispatch(min(find(mask)),:)) ''' as a valid ''Type'' value.']);
	end;
	ispatch =3D (col=3D=3Dpatchchar)*1 + (col=3D=3Dlinechar)*0 + =
(col=3D=3Ddefchar)*defispatch;
else,
	ispatch =3D ispatch(:);
end;
oldh =3D oldh(:);

% check object handles
if ~all(ishandle(oldh)), error([upper(mfilename) ' got invalid object =
handles.']); end;

% expand root, figure, and axes handles
if ~isempty(oldh),
	ohtype =3D get(oldh,'Type');
	mask =3D strcmp(ohtype,'root') | strcmp(ohtype,'figure') | =
strcmp(ohtype,'axes');
	if any(mask),
		oldh =3D num2cell(oldh);
		for ii=3Dfind(mask)',
			oldh(ii) =3D {findobj(oldh{ii},'Tag',ArrowTag)};
		end;
		oldh =3D cat(1,oldh{:});
		if isempty(oldh), return; end; % no arrows to modify, so just leave
	end;
end;

% largest argument length
[mstart,junk]=3Dsize(start); [mstop,junk]=3Dsize(stop); =
[mcrossdir,junk]=3Dsize(crossdir);
argsizes =3D [length(oldh) mstart mstop                              ...
            length(len) length(baseangle) length(tipangle)         ...
			length(wid) length(page) mcrossdir length(ends) ];
args=3D['length(ObjectHandle)  '; ...
      '#rows(Start)          '; ...
      '#rows(Stop)           '; ...
      'length(Length)        '; ...
      'length(BaseAngle)     '; ...
      'length(TipAngle)      '; ...
      'length(Width)         '; ...
      'length(Page)          '; ...
      '#rows(CrossDir)       '; ...
	  '#rows(Ends)           '];
if (any(imag(crossdir(:))~=3D0)),
	args(9,:) =3D '#rows(NormalDir)      ';
end;
if isempty(oldh),
	narrows =3D max(argsizes);
else,
	narrows =3D length(oldh);
end;
if (narrows&lt;=3D0), narrows=3D1; end;

% Check size of arguments
ii =3D =
find((argsizes~=3D0)&amp;(argsizes~=3D1)&amp;(argsizes~=3Dnarrows));
if ~isempty(ii),
	s =3D args(ii',:);
	while =
((size(s,2)&gt;1)&amp;((abs(s(:,size(s,2)))=3D=3D0)|(abs(s(:,size(s,2)))=3D=
=3Dabs(' ')))),
		s =3D s(:,1:size(s,2)-1);
	end;
	s =3D [ones(length(ii),1)*[upper(mfilename) ' requires that  '] s ...
	     ones(length(ii),1)*['  equal the # of arrows (' num2str(narrows) =
').' c]];
	s =3D s';
	s =3D s(:)';
	s =3D s(1:length(s)-1);
	error(setstr(s));
end;

% check element length in Start, Stop, and CrossDir
if ~isempty(start),
	[m,n] =3D size(start);
	if (n=3D=3D2),
		start =3D [start NaN*ones(m,1)];
	elseif (n~=3D3),
		error([upper(mfilename) ' requires 2- or 3-element Start points.']);
	end;
end;
if ~isempty(stop),
	[m,n] =3D size(stop);
	if (n=3D=3D2),
		stop =3D [stop NaN*ones(m,1)];
	elseif (n~=3D3),
		error([upper(mfilename) ' requires 2- or 3-element Stop points.']);
	end;
end;
if ~isempty(crossdir),
	[m,n] =3D size(crossdir);
	if (n&lt;3),
		crossdir =3D [crossdir NaN*ones(m,3-n)];
	elseif (n~=3D3),
		if (all(imag(crossdir(:))=3D=3D0)),
			error([upper(mfilename) ' requires 2- or 3-element CrossDir =
vectors.']);
		else,
			error([upper(mfilename) ' requires 2- or 3-element NormalDir =
vectors.']);
		end;
	end;
end;

% fill empty arguments
if isempty(start     ),   start      =3D [Inf Inf Inf];      end;
if isempty(stop      ),   stop       =3D [Inf Inf Inf];      end;
if isempty(len       ),   len        =3D Inf;                end;
if isempty(baseangle ),   baseangle  =3D Inf;                end;
if isempty(tipangle  ),   tipangle   =3D Inf;                end;
if isempty(wid       ),   wid        =3D Inf;                end;
if isempty(page      ),   page       =3D Inf;                end;
if isempty(crossdir  ),   crossdir   =3D [Inf Inf Inf];      end;
if isempty(ends      ),   ends       =3D Inf;                end;
if isempty(ispatch   ),   ispatch    =3D Inf;                end;

% expand single-column arguments
o =3D ones(narrows,1);
if (size(start     ,1)=3D=3D1),   start      =3D o * start     ;   end;
if (size(stop      ,1)=3D=3D1),   stop       =3D o * stop      ;   end;
if (length(len       )=3D=3D1),   len        =3D o * len       ;   end;
if (length(baseangle )=3D=3D1),   baseangle  =3D o * baseangle ;   end;
if (length(tipangle  )=3D=3D1),   tipangle   =3D o * tipangle  ;   end;
if (length(wid       )=3D=3D1),   wid        =3D o * wid       ;   end;
if (length(page      )=3D=3D1),   page       =3D o * page      ;   end;
if (size(crossdir  ,1)=3D=3D1),   crossdir   =3D o * crossdir  ;   end;
if (length(ends      )=3D=3D1),   ends       =3D o * ends      ;   end;
if (length(ispatch   )=3D=3D1),   ispatch    =3D o * ispatch   ;   end;
ax =3D o * gca;

% if we've got handles, get the defaults from the handles
if ~isempty(oldh),
	for k=3D1:narrows,
		oh =3D oldh(k);
		ud =3D get(oh,'UserData');
		ax(k) =3D get(oh,'Parent');
		ohtype =3D get(oh,'Type');
		if strcmp(get(oh,'Tag'),ArrowTag), % if it's an arrow already
			if isinf(ispatch(k)), ispatch(k)=3Dstrcmp(ohtype,'patch'); end;
			% arrow UserData format: [start' stop' len base tip wid page =
crossdir' ends]
			start0 =3D ud(1:3);
			stop0  =3D ud(4:6);
			if (isinf(len(k))),           len(k)        =3D ud( 7);   end;
			if (isinf(baseangle(k))),     baseangle(k)  =3D ud( 8);   end;
			if (isinf(tipangle(k))),      tipangle(k)   =3D ud( 9);   end;
			if (isinf(wid(k))),           wid(k)        =3D ud(10);   end;
			if (isinf(page(k))),          page(k)       =3D ud(11);   end;
			if (isinf(crossdir(k,1))),    crossdir(k,1) =3D ud(12);   end;
			if (isinf(crossdir(k,2))),    crossdir(k,2) =3D ud(13);   end;
			if (isinf(crossdir(k,3))),    crossdir(k,3) =3D ud(14);   end;
			if (isinf(ends(k))),          ends(k)       =3D ud(15);   end;
		elseif strcmp(ohtype,'line')|strcmp(ohtype,'patch'), % it's a =
non-arrow line or patch
			convLineToPatch =3D 1; %set to make arrow patches when converting =
from lines.
			if isinf(ispatch(k)), =
ispatch(k)=3DconvLineToPatch|strcmp(ohtype,'patch'); end;
			x=3Dget(oh,'XData');  x=3Dx(~isnan(x(:)));  if isempty(x), x=3DNaN; =
end;
			y=3Dget(oh,'YData');  y=3Dy(~isnan(y(:)));  if isempty(y), y=3DNaN; =
end;
			z=3Dget(oh,'ZData');  z=3Dz(~isnan(z(:)));  if isempty(z), z=3DNaN; =
end;
			start0 =3D [x(1)   y(1)   z(1)  ];
			stop0  =3D [x(end) y(end) z(end)];
		else,
			error([upper(mfilename) ' cannot convert ' ohtype ' objects.']);
		end;
		ii=3Dfind(isinf(start(k,:)));  if ~isempty(ii),  =
start(k,ii)=3Dstart0(ii);  end;
		ii=3Dfind(isinf(stop( k,:)));  if ~isempty(ii),  stop( k,ii)=3Dstop0( =
ii);  end;
	end;
end;

% convert Inf's to NaN's
start(     isinf(start    )) =3D NaN;
stop(      isinf(stop     )) =3D NaN;
len(       isinf(len      )) =3D NaN;
baseangle( isinf(baseangle)) =3D NaN;
tipangle(  isinf(tipangle )) =3D NaN;
wid(       isinf(wid      )) =3D NaN;
page(      isinf(page     )) =3D NaN;
crossdir(  isinf(crossdir )) =3D NaN;
ends(      isinf(ends     )) =3D NaN;
ispatch(   isinf(ispatch  )) =3D NaN;

% set up the UserData data (here so not corrupted by log10's and such)
ud =3D [start stop len baseangle tipangle wid page crossdir ends];

% Set Page defaults
page =3D ~isnan(page) &amp; trueornan(page);

% Get axes limits, range, min; correct for aspect ratio and log scale
axm       =3D zeros(3,narrows);
axr       =3D zeros(3,narrows);
axrev     =3D zeros(3,narrows);
ap        =3D zeros(2,narrows);
xyzlog    =3D zeros(3,narrows);
limmin    =3D zeros(2,narrows);
limrange  =3D zeros(2,narrows);
oldaxlims =3D zeros(narrows,7);
oneax =3D all(ax=3D=3Dax(1));
if (oneax),
	T    =3D zeros(4,4);
	invT =3D zeros(4,4);
else,
	T    =3D zeros(16,narrows);
	invT =3D zeros(16,narrows);
end;
axnotdone =3D logical(ones(size(ax)));
while (any(axnotdone)),
	ii =3D min(find(axnotdone));
	curax =3D ax(ii);
	curpage =3D page(ii);
	% get axes limits and aspect ratio
	axl =3D [get(curax,'XLim'); get(curax,'YLim'); get(curax,'ZLim')];
	oldaxlims(min(find(oldaxlims(:,1)=3D=3D0)),:) =3D [curax =
reshape(axl',1,6)];
	% get axes size in pixels (points)
	u =3D get(curax,'Units');
	axposoldunits =3D get(curax,'Position');
	really_curpage =3D curpage &amp; strcmp(u,'normalized');
	if (really_curpage),
		curfig =3D get(curax,'Parent');
		pu =3D get(curfig,'PaperUnits');
		set(curfig,'PaperUnits','points');
		pp =3D get(curfig,'PaperPosition');
		set(curfig,'PaperUnits',pu);
		set(curax,'Units','pixels');
		curapscreen =3D get(curax,'Position');
		set(curax,'Units','normalized');
		curap =3D pp.*get(curax,'Position');
	else,
		set(curax,'Units','pixels');
		curapscreen =3D get(curax,'Position');
		curap =3D curapscreen;
	end;
	set(curax,'Units',u);
	set(curax,'Position',axposoldunits);
	% handle non-stretched axes position
	str_stretch =3D { 'DataAspectRatioMode'    ; ...
	                'PlotBoxAspectRatioMode' ; ...
	                'CameraViewAngleMode'      };
	str_camera  =3D { 'CameraPositionMode'  ; ...
	                'CameraTargetMode'    ; ...
	                'CameraViewAngleMode' ; ...
	                'CameraUpVectorMode'    };
	notstretched =3D strcmp(get(curax,str_stretch),'manual');
	manualcamera =3D strcmp(get(curax,str_camera),'manual');
	if ~arrow_WarpToFill(notstretched,manualcamera,curax),
		% give a warning that this has not been thoroughly tested
		if 0 &amp; ARROW_STRETCH_WARN,
			ARROW_STRETCH_WARN =3D 0;
			strs =3D {str_stretch{1:2},str_camera{:}};
			strs =3D [char(ones(length(strs),1)*sprintf('\n    ')) char(strs)]';
			warning([upper(mfilename) ' may not yet work quite right ' ...
			         'if any of the following are ''manual'':' strs(:).']);
		end;
		% find the true pixel size of the actual axes
		texttmp =3D text(axl(1,[1 2 2 1 1 2 2 1]), ...
		               axl(2,[1 1 2 2 1 1 2 2]), ...
		               axl(3,[1 1 1 1 2 2 2 2]),'');
		set(texttmp,'Units','points');
		textpos =3D get(texttmp,'Position');
		delete(texttmp);
		textpos =3D cat(1,textpos{:});
		textpos =3D max(textpos(:,1:2)) - min(textpos(:,1:2));
		% adjust the axes position
		if (really_curpage),
			% adjust to printed size
			textpos =3D textpos * min(curap(3:4)./textpos);
			curap =3D [curap(1:2)+(curap(3:4)-textpos)/2 textpos];
		else,
			% adjust for pixel roundoff
			textpos =3D textpos * min(curapscreen(3:4)./textpos);
			curap =3D [curap(1:2)+(curap(3:4)-textpos)/2 textpos];
		end;
	end;
	if ARROW_PERSP_WARN &amp; =
~strcmp(get(curax,'Projection'),'orthographic'),
		ARROW_PERSP_WARN =3D 0;
		warning([upper(mfilename) ' does not yet work right for 3-D =
perspective projection.']);
	end;
	% adjust limits for log scale on axes
	curxyzlog =3D [strcmp(get(curax,'XScale'),'log'); ...
	             strcmp(get(curax,'YScale'),'log'); ...
	             strcmp(get(curax,'ZScale'),'log')];
	if (any(curxyzlog)),
		ii =3D find([curxyzlog;curxyzlog]);
		if (any(axl(ii)&lt;=3D0)),
			error([upper(mfilename) ' does not support non-positive limits on =
log-scaled axes.']);
		else,
			axl(ii) =3D log10(axl(ii));
		end;
	end;
	% correct for 'reverse' direction on axes;
	curreverse =3D [strcmp(get(curax,'XDir'),'reverse'); ...
	              strcmp(get(curax,'YDir'),'reverse'); ...
	              strcmp(get(curax,'ZDir'),'reverse')];
	ii =3D find(curreverse);
	if ~isempty(ii),
		axl(ii,[1 2])=3D-axl(ii,[2 1]);
	end;
	% compute the range of 2-D values
	curT =3D get(curax,'Xform');
	lim =3D curT*[0 1 0 1 0 1 0 1;0 0 1 1 0 0 1 1;0 0 0 0 1 1 1 1;1 1 1 1 1 =
1 1 1];
	lim =3D lim(1:2,:)./([1;1]*lim(4,:));
	curlimmin =3D min(lim')';
	curlimrange =3D max(lim')' - curlimmin;
	curinvT =3D inv(curT);
	if (~oneax),
		curT =3D curT.';
		curinvT =3D curinvT.';
		curT =3D curT(:);
		curinvT =3D curinvT(:);
	end;
	% check which arrows to which cur corresponds
	ii =3D find((ax=3D=3Dcurax)&amp;(page=3D=3Dcurpage));
	oo =3D ones(1,length(ii));
	axr(:,ii)      =3D diff(axl')' * oo;
	axm(:,ii)      =3D axl(:,1)    * oo;
	axrev(:,ii)    =3D curreverse  * oo;
	ap(:,ii)       =3D curap(3:4)' * oo;
	xyzlog(:,ii)   =3D curxyzlog   * oo;
	limmin(:,ii)   =3D curlimmin   * oo;
	limrange(:,ii) =3D curlimrange * oo;
	if (oneax),
		T    =3D curT;
		invT =3D curinvT;
	else,
		T(:,ii)    =3D curT    * oo;
		invT(:,ii) =3D curinvT * oo;
	end;
	axnotdone(ii) =3D zeros(1,length(ii));
end;
oldaxlims(oldaxlims(:,1)=3D=3D0,:)=3D[];

% correct for log scales
curxyzlog =3D xyzlog.';
ii =3D find(curxyzlog(:));
if ~isempty(ii),
	start(   ii) =3D real(log10(start(   ii)));
	stop(    ii) =3D real(log10(stop(    ii)));
	if (all(imag(crossdir)=3D=3D0)), % pulled (ii) subscript on crossdir, =
12/5/96 eaj
		crossdir(ii) =3D real(log10(crossdir(ii)));
	end;
end;

% correct for reverse directions
ii =3D find(axrev.');
if ~isempty(ii),
	start(   ii) =3D -start(   ii);
	stop(    ii) =3D -stop(    ii);
	crossdir(ii) =3D -crossdir(ii);
end;

% transpose start/stop values
start     =3D start.';
stop      =3D stop.';

% take care of defaults, page was done above
ii=3Dfind(isnan(start(:)       ));  if ~isempty(ii),  start(ii)       =
=3D axm(ii)+axr(ii)/2;                end;
ii=3Dfind(isnan(stop(:)        ));  if ~isempty(ii),  stop(ii)        =
=3D axm(ii)+axr(ii)/2;                end;
ii=3Dfind(isnan(crossdir(:)    ));  if ~isempty(ii),  crossdir(ii)    =
=3D zeros(length(ii),1);              end;
ii=3Dfind(isnan(len            ));  if ~isempty(ii),  len(ii)         =
=3D ones(length(ii),1)*deflen;        end;
ii=3Dfind(isnan(baseangle      ));  if ~isempty(ii),  baseangle(ii)   =
=3D ones(length(ii),1)*defbaseangle;  end;
ii=3Dfind(isnan(tipangle       ));  if ~isempty(ii),  tipangle(ii)    =
=3D ones(length(ii),1)*deftipangle;   end;
ii=3Dfind(isnan(wid            ));  if ~isempty(ii),  wid(ii)         =
=3D ones(length(ii),1)*defwid;        end;
ii=3Dfind(isnan(ends           ));  if ~isempty(ii),  ends(ii)        =
=3D ones(length(ii),1)*defends;       end;

% transpose rest of values
len       =3D len.';
baseangle =3D baseangle.';
tipangle  =3D tipangle.';
wid       =3D wid.';
page      =3D page.';
crossdir  =3D crossdir.';
ends      =3D ends.';
ax        =3D ax.';

% given x, a 3xN matrix of points in 3-space;
% want to convert to X, the corresponding 4xN 2-space matrix
%
%   tmp1=3D[(x-axm)./axr; ones(1,size(x,1))];
%   if (oneax), X=3DT*tmp1;
%   else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3DT.*tmp1;
%         tmp2=3Dzeros(4,4*N); tmp2(:)=3Dtmp1(:);
%         X=3Dzeros(4,N); X(:)=3Dsum(tmp2)'; end;
%   X =3D X ./ (ones(4,1)*X(4,:));

% for all points with start=3D=3Dstop, =
start=3Dstop-(verysmallvalue)*(up-direction);
ii =3D find(all(start=3D=3Dstop));
if ~isempty(ii),
	% find an arrowdir vertical on screen and perpendicular to viewer
	%	transform to 2-D
		tmp1 =3D [(stop(:,ii)-axm(:,ii))./axr(:,ii);ones(1,length(ii))];
		if (oneax), twoD=3DT*tmp1;
		else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3DT(:,ii).*tmp1;
		      tmp2=3Dzeros(4,4*length(ii)); tmp2(:)=3Dtmp1(:);
		      twoD=3Dzeros(4,length(ii)); twoD(:)=3Dsum(tmp2)'; end;
		twoD=3DtwoD./(ones(4,1)*twoD(4,:));
	%	move the start point down just slightly
		tmp1 =3D twoD + [0;-1/1000;0;0]*(limrange(2,ii)./ap(2,ii));
	%	transform back to 3-D
		if (oneax), threeD=3DinvT*tmp1;
		else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3DinvT(:,ii).*tmp1;
		      tmp2=3Dzeros(4,4*length(ii)); tmp2(:)=3Dtmp1(:);
		      threeD=3Dzeros(4,length(ii)); threeD(:)=3Dsum(tmp2)'; end;
		start(:,ii) =3D =
(threeD(1:3,:)./(ones(3,1)*threeD(4,:))).*axr(:,ii)+axm(:,ii);
end;

% compute along-arrow points
%	transform Start points
	tmp1=3D[(start-axm)./axr;ones(1,narrows)];
	if (oneax), X0=3DT*tmp1;
	else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3DT.*tmp1;
	      tmp2=3Dzeros(4,4*narrows); tmp2(:)=3Dtmp1(:);
	      X0=3Dzeros(4,narrows); X0(:)=3Dsum(tmp2)'; end;
	X0=3DX0./(ones(4,1)*X0(4,:));
%	transform Stop points
	tmp1=3D[(stop-axm)./axr;ones(1,narrows)];
	if (oneax), Xf=3DT*tmp1;
	else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3DT.*tmp1;
	      tmp2=3Dzeros(4,4*narrows); tmp2(:)=3Dtmp1(:);
	      Xf=3Dzeros(4,narrows); Xf(:)=3Dsum(tmp2)'; end;
	Xf=3DXf./(ones(4,1)*Xf(4,:));
%	compute pixel distance between points
	D =3D sqrt(sum(((Xf(1:2,:)-X0(1:2,:)).*(ap./limrange)).^2));
	D =3D D + (D=3D=3D0);  %eaj new 2/24/98
%	compute and modify along-arrow distances
	len1 =3D len;
	len2 =3D len - =
(len.*tan(tipangle/180*pi)-wid/2).*tan((90-baseangle)/180*pi);
	slen0 =3D zeros(1,narrows);
	slen1 =3D len1 .* ((ends=3D=3D2)|(ends=3D=3D3));
	slen2 =3D len2 .* ((ends=3D=3D2)|(ends=3D=3D3));
	len0 =3D zeros(1,narrows);
	len1  =3D len1 .* ((ends=3D=3D1)|(ends=3D=3D3));
	len2  =3D len2 .* ((ends=3D=3D1)|(ends=3D=3D3));
	%	for no start arrowhead
		ii=3Dfind((ends=3D=3D1)&amp;(D&lt;len2));
		if ~isempty(ii),
			slen0(ii) =3D D(ii)-len2(ii);
		end;
	%	for no end arrowhead
		ii=3Dfind((ends=3D=3D2)&amp;(D&lt;slen2));
		if ~isempty(ii),
			len0(ii) =3D D(ii)-slen2(ii);
		end;
	len1  =3D len1  + len0;
	len2  =3D len2  + len0;
	slen1 =3D slen1 + slen0;
	slen2 =3D slen2 + slen0;
 	% note:  the division by D below will probably not be accurate if both
 	%        of the following are true:
 	%           1. the ratio of the line length to the arrowhead
 	%              length is large
 	%           2. the view is highly perspective.
%	compute stoppoints
	tmp1=3DX0.*(ones(4,1)*(len0./D))+Xf.*(ones(4,1)*(1-len0./D));
	if (oneax), tmp3=3DinvT*tmp1;
	else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3DinvT.*tmp1;
	      tmp2=3Dzeros(4,4*narrows); tmp2(:)=3Dtmp1(:);
	      tmp3=3Dzeros(4,narrows); tmp3(:)=3Dsum(tmp2)'; end;
	stoppoint =3D tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
%	compute tippoints
	tmp1=3DX0.*(ones(4,1)*(len1./D))+Xf.*(ones(4,1)*(1-len1./D));
	if (oneax), tmp3=3DinvT*tmp1;
	else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3DinvT.*tmp1;
	      tmp2=3Dzeros(4,4*narrows); tmp2(:)=3Dtmp1(:);
	      tmp3=3Dzeros(4,narrows); tmp3(:)=3Dsum(tmp2)'; end;
	tippoint =3D tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
%	compute basepoints
	tmp1=3DX0.*(ones(4,1)*(len2./D))+Xf.*(ones(4,1)*(1-len2./D));
	if (oneax), tmp3=3DinvT*tmp1;
	else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3DinvT.*tmp1;
	      tmp2=3Dzeros(4,4*narrows); tmp2(:)=3Dtmp1(:);
	      tmp3=3Dzeros(4,narrows); tmp3(:)=3Dsum(tmp2)'; end;
	basepoint =3D tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
%	compute startpoints
	tmp1=3DX0.*(ones(4,1)*(1-slen0./D))+Xf.*(ones(4,1)*(slen0./D));
	if (oneax), tmp3=3DinvT*tmp1;
	else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3DinvT.*tmp1;
	      tmp2=3Dzeros(4,4*narrows); tmp2(:)=3Dtmp1(:);
	      tmp3=3Dzeros(4,narrows); tmp3(:)=3Dsum(tmp2)'; end;
	startpoint =3D tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
%	compute stippoints
	tmp1=3DX0.*(ones(4,1)*(1-slen1./D))+Xf.*(ones(4,1)*(slen1./D));
	if (oneax), tmp3=3DinvT*tmp1;
	else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3DinvT.*tmp1;
	      tmp2=3Dzeros(4,4*narrows); tmp2(:)=3Dtmp1(:);
	      tmp3=3Dzeros(4,narrows); tmp3(:)=3Dsum(tmp2)'; end;
	stippoint =3D tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
%	compute sbasepoints
	tmp1=3DX0.*(ones(4,1)*(1-slen2./D))+Xf.*(ones(4,1)*(slen2./D));
	if (oneax), tmp3=3DinvT*tmp1;
	else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3DinvT.*tmp1;
	      tmp2=3Dzeros(4,4*narrows); tmp2(:)=3Dtmp1(:);
	      tmp3=3Dzeros(4,narrows); tmp3(:)=3Dsum(tmp2)'; end;
	sbasepoint =3D tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;

% compute cross-arrow directions for arrows with NormalDir specified
if (any(imag(crossdir(:))~=3D0)),
	ii =3D find(any(imag(crossdir)~=3D0));
	crossdir(:,ii) =3D cross((stop(:,ii)-start(:,ii))./axr(:,ii), ...
	                       imag(crossdir(:,ii))).*axr(:,ii);
end;

% compute cross-arrow directions
basecross  =3D crossdir + basepoint;
tipcross   =3D crossdir + tippoint;
sbasecross =3D crossdir + sbasepoint;
stipcross  =3D crossdir + stippoint;
ii =3D find(all(crossdir=3D=3D0)|any(isnan(crossdir)));
if ~isempty(ii),
	numii =3D length(ii);
	%	transform start points
		tmp1 =3D [basepoint(:,ii) tippoint(:,ii) sbasepoint(:,ii) =
stippoint(:,ii)];
		tmp1 =3D (tmp1-axm(:,[ii ii ii ii])) ./ axr(:,[ii ii ii ii]);
		tmp1 =3D [tmp1; ones(1,4*numii)];
		if (oneax), X0=3DT*tmp1;
		else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3DT(:,[ii ii ii ii]).*tmp1;
		      tmp2=3Dzeros(4,16*numii); tmp2(:)=3Dtmp1(:);
		      X0=3Dzeros(4,4*numii); X0(:)=3Dsum(tmp2)'; end;
		X0=3DX0./(ones(4,1)*X0(4,:));
	%	transform stop points
		tmp1 =3D =
[(2*stop(:,ii)-start(:,ii)-axm(:,ii))./axr(:,ii);ones(1,numii)];
		tmp1 =3D [tmp1 tmp1 tmp1 tmp1];
		if (oneax), Xf=3DT*tmp1;
		else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3DT(:,[ii ii ii ii]).*tmp1;
		      tmp2=3Dzeros(4,16*numii); tmp2(:)=3Dtmp1(:);
		      Xf=3Dzeros(4,4*numii); Xf(:)=3Dsum(tmp2)'; end;
		Xf=3DXf./(ones(4,1)*Xf(4,:));
	%	compute perpendicular directions
		pixfact =3D =
((limrange(1,ii)./limrange(2,ii)).*(ap(2,ii)./ap(1,ii))).^2;
		pixfact =3D [pixfact pixfact pixfact pixfact];
		pixfact =3D [pixfact;1./pixfact];
		[dummyval,jj] =3D max(abs(Xf(1:2,:)-X0(1:2,:)));
		jj1 =3D ((1:4)'*ones(1,length(jj))=3D=3Dones(4,1)*jj);
		jj2 =3D ((1:4)'*ones(1,length(jj))=3D=3Dones(4,1)*(3-jj));
		jj3 =3D jj1(1:2,:);
		Xf(jj1)=3DXf(jj1)+(Xf(jj1)-X0(jj1)=3D=3D0); %eaj new 2/24/98
		Xp =3D X0;
		Xp(jj2) =3D X0(jj2) + ones(sum(jj2(:)),1);
		Xp(jj1) =3D X0(jj1) - (Xf(jj2)-X0(jj2))./(Xf(jj1)-X0(jj1)) .* =
pixfact(jj3);
	%	inverse transform the cross points
		if (oneax), Xp=3DinvT*Xp;
		else, tmp1=3D[Xp;Xp;Xp;Xp]; tmp1=3DinvT(:,[ii ii ii ii]).*tmp1;
		      tmp2=3Dzeros(4,16*numii); tmp2(:)=3Dtmp1(:);
		      Xp=3Dzeros(4,4*numii); Xp(:)=3Dsum(tmp2)'; end;
		Xp=3D(Xp(1:3,:)./(ones(3,1)*Xp(4,:))).*axr(:,[ii ii ii ii])+axm(:,[ii =
ii ii ii]);
		basecross(:,ii)  =3D Xp(:,0*numii+(1:numii));
		tipcross(:,ii)   =3D Xp(:,1*numii+(1:numii));
		sbasecross(:,ii) =3D Xp(:,2*numii+(1:numii));
		stipcross(:,ii)  =3D Xp(:,3*numii+(1:numii));
end;

% compute all points
%	compute start points
	axm11 =3D [axm axm axm axm axm axm axm axm axm axm axm];
	axr11 =3D [axr axr axr axr axr axr axr axr axr axr axr];
	st =3D [stoppoint tippoint basepoint sbasepoint stippoint startpoint =
stippoint sbasepoint basepoint tippoint stoppoint];
	tmp1 =3D (st - axm11) ./ axr11;
	tmp1 =3D [tmp1; ones(1,size(tmp1,2))];
	if (oneax), X0=3DT*tmp1;
	else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3D[T T T T T T T T T T =
T].*tmp1;
	      tmp2=3Dzeros(4,44*narrows); tmp2(:)=3Dtmp1(:);
	      X0=3Dzeros(4,11*narrows); X0(:)=3Dsum(tmp2)'; end;
	X0=3DX0./(ones(4,1)*X0(4,:));
%	compute stop points
	tmp1 =3D ([start tipcross basecross sbasecross stipcross stop stipcross =
sbasecross basecross tipcross start] ...
	     - axm11) ./ axr11;
	tmp1 =3D [tmp1; ones(1,size(tmp1,2))];
	if (oneax), Xf=3DT*tmp1;
	else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3D[T T T T T T T T T T =
T].*tmp1;
	      tmp2=3Dzeros(4,44*narrows); tmp2(:)=3Dtmp1(:);
	      Xf=3Dzeros(4,11*narrows); Xf(:)=3Dsum(tmp2)'; end;
	Xf=3DXf./(ones(4,1)*Xf(4,:));
%	compute lengths
	len0  =3D len.*((ends=3D=3D1)|(ends=3D=3D3)).*tan(tipangle/180*pi);
	slen0 =3D len.*((ends=3D=3D2)|(ends=3D=3D3)).*tan(tipangle/180*pi);
	le =3D [zeros(1,narrows) len0 wid/2 wid/2 slen0 zeros(1,narrows) -slen0 =
-wid/2 -wid/2 -len0 zeros(1,narrows)];
	aprange =3D ap./limrange;
	aprange =3D [aprange aprange aprange aprange aprange aprange aprange =
aprange aprange aprange aprange];
	D =3D sqrt(sum(((Xf(1:2,:)-X0(1:2,:)).*aprange).^2));
	Dii=3Dfind(D=3D=3D0); if ~isempty(Dii), D=3DD+(D=3D=3D0); =
le(Dii)=3Dzeros(1,length(Dii)); end; %should fix DivideByZero warnings
	tmp1 =3D X0.*(ones(4,1)*(1-le./D)) + Xf.*(ones(4,1)*(le./D));
%	inverse transform
	if (oneax), tmp3=3DinvT*tmp1;
	else, tmp1=3D[tmp1;tmp1;tmp1;tmp1]; tmp1=3D[invT invT invT invT invT =
invT invT invT invT invT invT].*tmp1;
	      tmp2=3Dzeros(4,44*narrows); tmp2(:)=3Dtmp1(:);
	      tmp3=3Dzeros(4,11*narrows); tmp3(:)=3Dsum(tmp2)'; end;
	pts =3D tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)) .* axr11 + axm11;

% correct for ones where the crossdir was specified
ii =3D find(~(all(crossdir=3D=3D0)|any(isnan(crossdir))));
if ~isempty(ii),
	D1 =3D [pts(:,1*narrows+ii)-pts(:,9*narrows+ii) ...
	      pts(:,2*narrows+ii)-pts(:,8*narrows+ii) ...
	      pts(:,3*narrows+ii)-pts(:,7*narrows+ii) ...
	      pts(:,4*narrows+ii)-pts(:,6*narrows+ii) ...
	      pts(:,6*narrows+ii)-pts(:,4*narrows+ii) ...
	      pts(:,7*narrows+ii)-pts(:,3*narrows+ii) ...
	      pts(:,8*narrows+ii)-pts(:,2*narrows+ii) ...
	      pts(:,9*narrows+ii)-pts(:,1*narrows+ii)]/2;
	ii =3D ii'*ones(1,8) + ones(length(ii),1)*[1:4 6:9]*narrows;
	ii =3D ii(:)';
	pts(:,ii) =3D st(:,ii) + D1;
end;


% readjust for reverse directions
iicols=3D(1:narrows)'; iicols=3Diicols(:,ones(1,11)); =
iicols=3Diicols(:).';
tmp1=3Daxrev(:,iicols);
ii =3D find(tmp1(:)); if ~isempty(ii), pts(ii)=3D-pts(ii); end;

% readjust for log scale on axes
tmp1=3Dxyzlog(:,iicols);
ii =3D find(tmp1(:)); if ~isempty(ii), pts(ii)=3D10.^pts(ii); end;

% compute the x,y,z coordinates of the patches;
ii =3D narrows*(0:10)'*ones(1,narrows) + ones(11,1)*(1:narrows);
ii =3D ii(:)';
x =3D zeros(11,narrows);
y =3D zeros(11,narrows);
z =3D zeros(11,narrows);
x(:) =3D pts(1,ii)';
y(:) =3D pts(2,ii)';
z(:) =3D pts(3,ii)';

% do the output
if (nargout&lt;=3D1),
%	% create or modify the patches
	newpatch =3D trueornan(ispatch) &amp; =
(isempty(oldh)|~strcmp(get(oldh,'Type'),'patch'));
	newline =3D ~trueornan(ispatch) &amp; =
(isempty(oldh)|~strcmp(get(oldh,'Type'),'line'));
	if isempty(oldh), H=3Dzeros(narrows,1); else, H=3Doldh; end;
%	% make or modify the arrows
	for k=3D1:narrows,
		if all(isnan(ud(k,[3 6])))&amp;arrow_is2DXY(ax(k)), zz=3D[]; else, =
zz=3Dz(:,k); end;
		% work around a MATLAB 6.x OpenGL bug -- 7/28/02
		  xx=3Dx(:,k); yy=3Dy(:,k);=20
		  mask=3Dany([ones(1,2+size(zz,2));diff([xx yy zz],[],1)],2);
		  xx=3Dxx(mask); yy=3Dyy(mask); if ~isempty(zz), zz=3Dzz(mask); end;
		% plot the patch or line
		xyz =3D {'XData',xx,'YData',yy,'ZData',zz,'Tag',ArrowTag};
		if newpatch(k)|newline(k),
			if newpatch(k),
				H(k) =3D patch(xyz{:});
			else,
				H(k) =3D line(xyz{:});
			end;
			if ~isempty(oldh), arrow_copyprops(oldh(k),H(k)); end;
		else,
			if ispatch(k), xyz=3D{xyz{:},'CData',[]}; end;
			set(H(k),xyz{:});
		end;
	end;
	if ~isempty(oldh), delete(oldh(oldh~=3DH)); end;
%	% additional properties
	set(H,'Clipping','off');
	set(H,{'UserData'},num2cell(ud,2));
	if (length(extraprops)&gt;0), set(H,extraprops{:}); end;
	% handle choosing arrow Start and/or Stop locations if unspecified
	[H,oldaxlims,errstr] =3D arrow_clicks(H,ud,x,y,z,ax,oldaxlims);
	if ~isempty(errstr), error([upper(mfilename) ' got ' errstr]); end;
	% set the output
	if (nargout&gt;0), h=3DH; end;
	% make sure the axis limits did not change
	if isempty(oldaxlims),
		ARROW_AXLIMITS =3D [];
	else,
		lims =3D get(oldaxlims(:,1),{'XLim','YLim','ZLim'})';
		lims =3D reshape(cat(2,lims{:}),6,size(lims,2));
		mask =3D arrow_is2DXY(oldaxlims(:,1));
		oldaxlims(mask,6:7) =3D lims(5:6,mask)';
		ARROW_AXLIMITS =3D oldaxlims(find(any(oldaxlims(:,2:7)'~=3Dlims)),:);
		if ~isempty(ARROW_AXLIMITS),
			warning(arrow_warnlimits(ARROW_AXLIMITS,narrows));
		end;
	end;
else,
	% don't create the patch, just return the data
	h=3Dx;
	yy=3Dy;
	zz=3Dz;
end;



function out =3D arrow_defcheck(in,def,prop)
% check if we got 'default' values
	out =3D in;
	if ~isstr(in), return; end;
	if size(in,1)=3D=3D1 &amp; strncmp(lower(in),'def',3),
		out =3D def;
	elseif ~isempty(prop),
		error([upper(mfilename) ' does not recognize ''' in(:)' ''' as a valid =
''' prop ''' string.']);
	end;



function [H,oldaxlims,errstr] =3D arrow_clicks(H,ud,x,y,z,ax,oldaxlims)
% handle choosing arrow Start and/or Stop locations if necessary
	errstr =3D '';
	if isempty(H)|isempty(ud)|isempty(x), return; end;
	% determine which (if any) need Start and/or Stop
	needStart =3D all(isnan(ud(:,1:3)'))';
	needStop  =3D all(isnan(ud(:,4:6)'))';
	mask =3D any(needStart|needStop);
	if ~any(mask), return; end;
	ud(~mask,:)=3D[]; ax(:,~mask)=3D[];
	x(:,~mask)=3D[]; y(:,~mask)=3D[]; z(:,~mask)=3D[];
	% make them invisible for the time being
	set(H,'Visible','off');
	% save the current axes and limits modes; set to manual for the time =
being
	oldAx  =3D gca;
	limModes=3Dget(ax(:),{'XLimMode','YLimMode','ZLimMode'});
	=
set(ax(:),{'XLimMode','YLimMode','ZLimMode'},{'manual','manual','manual'}=
);
	% loop over each arrow that requires attention
	jj =3D find(mask);
	for ii=3D1:length(jj),
		h =3D H(jj(ii));
		axes(ax(ii));
		% figure out correct call
		if needStart(ii), prop=3D'Start'; else, prop=3D'Stop'; end;
		[wasInterrupted,errstr] =3D =
arrow_click(needStart(ii)&amp;needStop(ii),h,prop,ax(ii));
		% handle errors and control-C
		if wasInterrupted,
			delete(H(jj(ii:end)));
			H(jj(ii:end))=3D[];
			oldaxlims(jj(ii:end),:)=3D[];
			break;
		end;
	end;
	% restore the axes and limit modes
	axes(oldAx);
	set(ax(:),{'XLimMode','YLimMode','ZLimMode'},limModes);

function [wasInterrupted,errstr] =3D arrow_click(lockStart,H,prop,ax)
% handle the clicks for one arrow
	fig =3D get(ax,'Parent');
	% save some things
	oldFigProps =3D =
{'Pointer','WindowButtonMotionFcn','WindowButtonUpFcn'};
	oldFigValue =3D get(fig,oldFigProps);
	oldArrowProps =3D {'EraseMode'};
	oldArrowValue =3D get(H,oldArrowProps);
	set(H,'EraseMode','background'); %because 'xor' makes shaft invisible =
unless Width&gt;1
	global ARROW_CLICK_H ARROW_CLICK_PROP ARROW_CLICK_AX ARROW_CLICK_USE_Z
	ARROW_CLICK_H=3DH; ARROW_CLICK_PROP=3Dprop; ARROW_CLICK_AX=3Dax;
	ARROW_CLICK_USE_Z=3D~arrow_is2DXY(ax)|~arrow_planarkids(ax);
	set(fig,'Pointer','crosshair');
	% set up the WindowButtonMotion so we can see the arrow while moving =
around
	set(fig,'WindowButtonUpFcn','set(gcf,''WindowButtonUpFcn'','''')', ...
	        'WindowButtonMotionFcn','');
	if ~lockStart,
		set(H,'Visible','on');
		set(fig,'WindowButtonMotionFcn',[mfilename =
'(''callback'',''motion'');']);
	end;
	% wait for the button to be pressed
	[wasKeyPress,wasInterrupted,errstr] =3D arrow_wfbdown(fig);
	% if we wanted to click-drag, set the Start point
	if lockStart &amp; ~wasInterrupted,
		pt =3D arrow_point(ARROW_CLICK_AX,ARROW_CLICK_USE_Z);
		feval(mfilename,H,'Start',pt,'Stop',pt);
		set(H,'Visible','on');
		ARROW_CLICK_PROP=3D'Stop';
		set(fig,'WindowButtonMotionFcn',[mfilename =
'(''callback'',''motion'');']);
		% wait for the mouse button to be released
		=
eval('waitfor(fig,''WindowButtonUpFcn'','''');','wasInterrupted=3D1;');
		if wasInterrupted, errstr=3Dlasterr; end;
	end;
	if ~wasInterrupted, feval(mfilename,'callback','motion'); end;
	% restore some things
	set(gcf,oldFigProps,oldFigValue);
	set(H,oldArrowProps,oldArrowValue);

function arrow_callback(varargin)
% handle redrawing callbacks
	if nargin=3D=3D0, return; end;
	str =3D varargin{1};
	if ~isstr(str), error([upper(mfilename) ' got an invalid Callback =
command.']); end;
	s =3D lower(str);
	if strcmp(s,'motion'),
		% motion callback
		global ARROW_CLICK_H ARROW_CLICK_PROP ARROW_CLICK_AX ARROW_CLICK_USE_Z
		=
feval(mfilename,ARROW_CLICK_H,ARROW_CLICK_PROP,arrow_point(ARROW_CLICK_AX=
,ARROW_CLICK_USE_Z));
		drawnow;
	else,
		error([upper(mfilename) ' does not recognize ''' str(:).' ''' as a =
valid Callback option.']);
	end;

function out =3D arrow_point(ax,use_z)
% return the point on the given axes
	if nargin=3D=3D0, ax=3Dgca; end;
	if nargin&lt;2, use_z=3D~arrow_is2DXY(ax)|~arrow_planarkids(ax); end;
	out =3D get(ax,'CurrentPoint');
	out =3D out(1,:);
	if ~use_z, out=3Dout(1:2); end;

function [wasKeyPress,wasInterrupted,errstr] =3D arrow_wfbdown(fig)
% wait for button down ignoring object ButtonDownFcn's
	if nargin=3D=3D0, fig=3Dgcf; end;
	errstr =3D '';
	% save ButtonDownFcn values
	objs =3D findobj(fig);
	buttonDownFcns =3D get(objs,'ButtonDownFcn');
	mask=3D~strcmp(buttonDownFcns,''); objs=3Dobjs(mask); =
buttonDownFcns=3DbuttonDownFcns(mask);
	set(objs,'ButtonDownFcn','');
	% save other figure values
	figProps =3D {'KeyPressFcn','WindowButtonDownFcn'};
	figValue =3D get(fig,figProps);
	% do the real work
	=
set(fig,'KeyPressFcn','set(gcf,''KeyPressFcn'','''',''WindowButtonDownFcn=
'','''');', ...
	        'WindowButtonDownFcn','set(gcf,''WindowButtonDownFcn'','''')');
	lasterr('');
	wasInterrupted=3D0; =
eval('waitfor(fig,''WindowButtonDownFcn'','''');','wasInterrupted=3D1;');=

	wasKeyPress =3D ~wasInterrupted &amp; =
strcmp(get(fig,'KeyPressFcn'),'');
	if wasInterrupted, errstr=3Dlasterr; end;
	% restore ButtonDownFcn and other figure values
	set(objs,'ButtonDownFcn',buttonDownFcns);
	set(fig,figProps,figValue);



function [out,is2D] =3D arrow_is2DXY(ax)
% check if axes are 2-D X-Y plots
	% may not work for modified camera angles, etc.
	out =3D logical(zeros(size(ax))); % 2-D X-Y plots
	is2D =3D out;                     % any 2-D plots
	views =3D get(ax(:),{'View'});
	views =3D cat(1,views{:});
	out(:) =3D abs(views(:,2))=3D=3D90;
	is2D(:) =3D out(:) | all(rem(views',90)=3D=3D0)';

function out =3D arrow_planarkids(ax)
% check if axes descendents all have empty ZData =
(lines,patches,surfaces)
	out =3D logical(ones(size(ax)));
	allkids =3D get(ax(:),{'Children'});
	for k=3D1:length(allkids),
		kids =3D get([findobj(allkids{k},'flat','Type','line')
		            findobj(allkids{k},'flat','Type','patch')
		            findobj(allkids{k},'flat','Type','surface')],{'ZData'});
		for j=3D1:length(kids),
			if ~isempty(kids{j}), out(k)=3Dlogical(0); break; end;
		end;
	end;



function arrow_fixlimits(axlimits)
% reset the axis limits as necessary
	if isempty(axlimits), disp([upper(mfilename) ' does not remember any =
axis limits to reset.']); end;
	for k=3D1:size(axlimits,1),
		if any(get(axlimits(k,1),'XLim')~=3Daxlimits(k,2:3)), =
set(axlimits(k,1),'XLim',axlimits(k,2:3)); end;
		if any(get(axlimits(k,1),'YLim')~=3Daxlimits(k,4:5)), =
set(axlimits(k,1),'YLim',axlimits(k,4:5)); end;
		if any(get(axlimits(k,1),'ZLim')~=3Daxlimits(k,6:7)), =
set(axlimits(k,1),'ZLim',axlimits(k,6:7)); end;
	end;



function out =3D arrow_WarpToFill(notstretched,manualcamera,curax)
% check if we are in "WarpToFill" mode.
	out =3D strcmp(get(curax,'WarpToFill'),'on');
	% 'WarpToFill' is undocumented, so may need to replace this by
	% out =3D ~( any(notstretched) &amp; any(manualcamera) );



function out =3D arrow_warnlimits(axlimits,narrows)
% create a warning message if we've changed the axis limits
	msg =3D '';
	switch (size(axlimits,1))
		case 1, msg=3D'';
		case 2, msg=3D'on two axes ';
		otherwise, msg=3D'on several axes ';
	end;
	msg =3D [upper(mfilename) ' changed the axis limits ' msg ...
	       'when adding the arrow'];
	if (narrows&gt;1), msg=3D[msg 's']; end;
	out =3D [msg '.' sprintf('\n') '         Call ' upper(mfilename) ...
	       ' FIXLIMITS to reset them now.'];



function arrow_copyprops(fm,to)
% copy line properties to patches
	props  =3D =
{'EraseMode','LineStyle','LineWidth','Marker','MarkerSize',...
	          'MarkerEdgeColor','MarkerFaceColor','ButtonDownFcn',      ...
	          'Clipping','DeleteFcn','BusyAction','HandleVisibility',   ...
	          'Selected','SelectionHighlight','Visible'};
	lineprops  =3D {'Color',    props{:}};
	patchprops =3D {'EdgeColor',props{:}};
	patch2props =3D {'FaceColor',patchprops{:}};
	fmpatch =3D strcmp(get(fm,'Type'),'patch');
	topatch =3D strcmp(get(to,'Type'),'patch');
	set(to( fmpatch&amp; topatch),patch2props,get(fm( fmpatch&amp; =
topatch),patch2props)); %p-&gt;p
	set(to(~fmpatch&amp;~topatch),lineprops,  =
get(fm(~fmpatch&amp;~topatch),lineprops  )); %l-&gt;l
	set(to( fmpatch&amp;~topatch),lineprops,  get(fm( =
fmpatch&amp;~topatch),patchprops )); %p-&gt;l
	set(to(~fmpatch&amp; topatch),patchprops, get(fm(~fmpatch&amp; =
topatch),lineprops)  ,'FaceColor','none'); %l-&gt;p



function arrow_props
% display further help info about ARROW properties
	c =3D sprintf('\n');
	disp([c ...
	'ARROW Properties:  Default values are given in [square brackets], and =
other' c ...
	'                   acceptable equivalent property names are in =
(parenthesis).' c c ...
	'  Start           The starting points. For N arrows,            B' c =
...
	'                  this should be a Nx2 or Nx3 matrix.          /|\     =
      ^' c ...
	'  Stop            The end points. For N arrows, this          /|||\    =
      |' c ...
	'                  should be a Nx2 or Nx3 matrix.             //|||\\   =
     L|' c ...
	'  Length          Length of the arrowhead (in pixels on     ///|||\\\  =
     e|' c ...
	'                  screen, points on a page). [16] (Len)    ////|||\\\\ =
     n|' c ...
	'  BaseAngle       Angle (degrees) of the base angle       =
/////|D|\\\\\     g|' c ...
	'                  ADE.  For a simple stick arrow, use    ////  |||  =
\\\\    t|' c ...
	'                  BaseAngle=3DTipAngle. [90] (Base)       ///    |||   =
 \\\   h|' c ...
	'  TipAngle        Angle (degrees) of tip angle ABC.    =
//&lt;-----&gt;||      \\   |' c ...
	'                  [16] (Tip)                          /   base |||     =
   \  V' c ...
	'  Width           Width of the base in pixels.  Not  E   angle =
||&lt;--------&gt;C' c ...
	'                  the ''LineWidth'' prop. [0] (Wid)            =
|||tipangle' c ...
	'  Page            If provided, non-empty, and not NaN,         |||' c =
...
	'                  this causes ARROW to use hardcopy            |||' c =
...
	'                  rather than onscreen proportions.             A' c =
...
	'                  This is important if screen aspect        --&gt;   =
&lt;-- width' c ...
	'                  ratio and hardcopy aspect ratio are    =
----CrossDir----&gt;' c ...
	'                  vastly different. []' c...
	'  CrossDir        A vector giving the direction towards which the =
fletches' c ...
	'                  on the arrow should go.  [computed such that it is =
perpen-' c ...
	'                  dicular to both the arrow direction and the view =
direction' c ...
	'                  (i.e., as if it was pasted on a normal 2-D graph)]  =
(Note' c ...
	'                  that CrossDir is a vector.  Also note that if an =
axis is' c ...
	'                  plotted on a log scale, then the corresponding =
component' c ...
	'                  of CrossDir must also be set appropriately, i.e., to =
1 for' c ...
	'                  no change in that direction, &gt;1 for a positive =
change, &gt;0' c ...
	'                  and &lt;1 for negative change.)' c ...
	'  NormalDir       A vector normal to the fletch direction (CrossDir is =
then' c ...
	'                  computed by the vector cross product =
[Line]x[NormalDir]). []' c ...
	'                  (Note that NormalDir is a vector.  Unlike CrossDir,' =
c ...
	'                  NormalDir is used as is regardless of log-scaled =
axes.)' c ...
	'  Ends            Set which end has an arrowhead.  Valid values are =
''none'',' c ...
	'                  ''stop'', ''start'', and ''both''. [''stop''] (End)' =
c...
	'  ObjectHandles   Vector of handles to previously-created arrows to =
be' c ...
	'                  updated or line objects to be converted to arrows.' =
c ...
	'                  [] (Object,Handle)' c ]);



function out =3D arrow_demo
 	% demo
	% create the data
	[x,y,z] =3D peaks;
	[ddd,out.iii]=3Dmax(z(:));
	out.axlim =3D [min(x(:)) max(x(:)) min(y(:)) max(y(:)) min(z(:)) =
max(z(:))];
=09
	% modify it by inserting some NaN's
	[m,n] =3D size(z);
	m =3D floor(m/2);
	n =3D floor(n/2);
	z(1:m,1:n) =3D NaN*ones(m,n);
=09
	% graph it
	clf('reset');
	out.hs=3Dsurf(x,y,z);
	out.x=3Dx; out.y=3Dy; out.z=3Dz;
	xlabel('x'); ylabel('y');
		=09
function h =3D arrow_demo3(in)
	% set the view
	axlim =3D in.axlim;
	axis(axlim);
	zlabel('z');
	%set(in.hs,'FaceColor','interp');
	view(viewmtx(-37.5,30,20));
	title(['Demo of the capabilities of the ARROW function in 3-D']);
=09
	% Normal blue arrow
	h1 =3D feval(mfilename,[axlim(1) axlim(4) 4],[-.8 1.2 4], ...
	           'EdgeColor','b','FaceColor','b');
=09
	% Normal white arrow, clipped by the surface
	h2 =3D feval(mfilename,axlim([1 4 6]),[0 2 4]);
	t=3Dtext(-2.4,2.7,7.7,'arrow clipped by surf');
=09
	% Baseangle&lt;90
	h3 =3D feval(mfilename,[3 .125 3.5],[1.375 0.125 3.5],30,50);
	t2=3Dtext(3.1,.125,3.5,'local maximum');
=09
	% Baseangle&lt;90, fill and edge colors different
	h4 =3D feval(mfilename,axlim(1:2:5)*.5,[0 0 0],36,60,25, ...
	           'EdgeColor','b','FaceColor','c');
	t3=3Dtext(axlim(1)*.5,axlim(3)*.5,axlim(5)*.5-.75,'origin');
	set(t3,'HorizontalAlignment','center');
=09
	% Baseangle&gt;90, black fill
	h5 =3D feval(mfilename,[-2.9 2.9 3],[-1.3 .4 3.2],30,120,[],6, ...
	           'EdgeColor','r','FaceColor','k','LineWidth',2);
=09
	% Baseangle&gt;90, no fill
	h6 =3D feval(mfilename,[-2.9 2.9 1.3],[-1.3 .4 1.5],30,120,[],6, ...
	           'EdgeColor','r','FaceColor','none','LineWidth',2);
=09
	% Stick arrow
	h7 =3D feval(mfilename,[-1.6 -1.65 -6.5],[0 -1.65 -6.5],[],16,16);
	t4=3Dtext(-1.5,-1.65,-7.25,'global mininum');
	set(t4,'HorizontalAlignment','center');
=09
	% Normal, black fill
	h8 =3D feval(mfilename,[-1.4 0 -7.2],[-1.4 0 -3],'FaceColor','k');
	t5=3Dtext(-1.5,0,-7.75,'local minimum');
	set(t5,'HorizontalAlignment','center');
=09
	% Gray fill, crossdir specified, 'LineStyle' --
	h9 =3D feval(mfilename,[-3 2.2 -6],[-3 2.2 -.05],36,[],27,6,[],[0 -1 =
0], ...
	           'EdgeColor','k','FaceColor',.75*[1 1 1],'LineStyle','--');
=09
	% a series of normal arrows, linearly spaced, crossdir specified
	h10y=3D(0:4)'/3;
	h10 =3D feval(mfilename,[-3*ones(size(h10y)) h10y =
-6.5*ones(size(h10y))], ...
	            [-3*ones(size(h10y)) h10y -.05*ones(size(h10y))], ...
	            12,[],[],[],[],[0 -1 0]);
=09
	% a series of normal arrows, linearly spaced
	h11x=3D(1:.33:2.8)';
	h11 =3D feval(mfilename,[h11x -3*ones(size(h11x)) =
6.5*ones(size(h11x))], ...
	            [h11x -3*ones(size(h11x)) -.05*ones(size(h11x))]);
=09
	% series of magenta arrows, radially oriented, crossdir specified
	h12x=3D2; h12y=3D-3; h12z=3Daxlim(5)/2; h12xr=3D1; h12zr=3Dh12z; =
ir=3D.15;or=3D.81;
	h12t=3D(0:11)'/6*pi;
	h12 =3D feval(mfilename,                                           ...
	            [h12x+h12xr*cos(h12t)*ir h12y*ones(size(h12t))       ...
	             h12z+h12zr*sin(h12t)*ir],[h12x+h12xr*cos(h12t)*or   ...
	             h12y*ones(size(h12t)) h12z+h12zr*sin(h12t)*or],     ...
	            10,[],[],[],[],                                      ...
	            [-h12xr*sin(h12t) zeros(size(h12t)) h12zr*cos(h12t)],...
	            'FaceColor','none','EdgeColor','m');
=09
	% series of normal arrows, tangentially oriented, crossdir specified
	or13=3D.91; h13t=3D(0:.5:12)'/6*pi;
	locs =3D [h12x+h12xr*cos(h13t)*or13 h12y*ones(size(h13t)) =
h12z+h12zr*sin(h13t)*or13];
	h13 =3D feval(mfilename,locs(1:end-1,:),locs(2:end,:),6);
=09
	% arrow with no line =3D=3D&gt; oriented downwards
	h14 =3D feval(mfilename,[3 3 .100001],[3 3 .1],30);
	t6=3Dtext(3,3,3.6,'no line'); set(t6,'HorizontalAlignment','center');
=09
	% arrow with arrowheads at both ends
	h15 =3D feval(mfilename,[-.5 -3 -3],[1 -3 =
-3],'Ends','both','FaceColor','g', ...
	            'Length',20,'Width',3,'CrossDir',[0 0 1],'TipAngle',25);
=09
	h=3D[h1;h2;h3;h4;h5;h6;h7;h8;h9;h10;h11;h12;h13;h14;h15];

function h =3D arrow_demo2(in)
	axlim =3D in.axlim;
	dolog =3D 1;
	if (dolog), set(in.hs,'YData',10.^get(in.hs,'YData')); end;
	shading('interp');
	view(2);
	title(['Demo of the capabilities of the ARROW function in 2-D']);
	hold on; [C,H]=3Dcontour(in.x,in.y,in.z,20,'-'); hold off;
	for k=3DH',
		set(k,'ZData',(axlim(6)+1)*ones(size(get(k,'XData'))),'Color','k');
		if (dolog), set(k,'YData',10.^get(k,'YData')); end;
	end;
	if (dolog), axis([axlim(1:2) 10.^axlim(3:4)]); set(gca,'YScale','log');
	else,       axis(axlim(1:4)); end;
=09
	% Normal blue arrow
	start =3D [axlim(1) axlim(4) axlim(6)+2];
	stop  =3D [in.x(in.iii) in.y(in.iii) axlim(6)+2];
	if (dolog), start(:,2)=3D10.^start(:,2); stop(:,2)=3D10.^stop(:,2); =
end;
	h1 =3D feval(mfilename,start,stop,'EdgeColor','b','FaceColor','b');
=09
	% three arrows with varying fill, width, and baseangle
	start =3D [-3   -3   10; -3   -1.5 10; -1.5 -3   10];
	stop  =3D [-.03 -.03 10; -.03 -1.5 10; -1.5 -.03 10];
	if (dolog), start(:,2)=3D10.^start(:,2); stop(:,2)=3D10.^stop(:,2); =
end;
	h2 =3D =
feval(mfilename,start,stop,24,[90;60;120],[],[0;0;4],'Ends',str2mat('both=
','stop','stop'));
	set(h2(2),'EdgeColor',[0 .35 0],'FaceColor',[0 .85 .85]);
	set(h2(3),'EdgeColor','r','FaceColor',[1 .5 1]);
	h=3D[h1;h2];

function out =3D trueornan(x)
if isempty(x),
	out=3Dx;
else,
	out =3D isnan(x);
	out(~out) =3D x(~out);
end;
</PRE></BODY></HTML>
